# PHP 
PHP — это популярный скриптовый язык программирования с открытым исходным кодом, разработанный в первую очередь для веб-разработки, который позволяет создавать динамические веб-страницы, обрабатывать данные форм и работать с базами данных.

## Основы синтаксиса 
Основы синтаксиса PHP включают: начало и конец скрипта с помощью тегов <?php и ?>, завершение каждого оператора точкой с запятой ;, объявление переменных с использованием знака доллара ($), определение блоков с помощью фигурных скобок {} и использование комментариев //, # или /* */ для пояснений. 
1. Теги скрипта
PHP-код находится внутри тегов <?php и ?>. Весь код, заключенный между ними, выполняется на сервере. 
2. Операторы и точка с запятой
Каждая инструкция в PHP должна завершаться точкой с запятой (;). 
3. Переменные 

    Переменные объявляются с помощью знака доллара ($).
    Имя переменной не может начинаться с цифры.
    Примеры: $myVariable, $user_name1. 

4. Блоки кода 

    Блоки кода объединяют несколько инструкций и выделяются фигурными скобками {}.
    Точка с запятой после закрывающей фигурной скобки необязательна. 

5. Комментарии Для однострочных комментариев используются // или #, Для многострочных комментариев применяется /* */. 

## Циклы
В PHP существует четыре основных типа циклов: for для заданного числа итераций, while для выполнения кода пока условие истинно, do-while для выполнения кода хотя бы один раз и последующей проверки условия, и foreach для перебора всех элементов массива или объекта. Ниже приведены примеры каждого из них: 
1. Цикл for
Используется, когда заранее известно, сколько раз нужно выполнить блок кода. 
Код

```php
<?php
for ($i = 0; $i < 5; $i++) {
    echo "Итерация номер " . $i . "<br>";
}
?>
```

В этом примере код внутри цикла выполнится 5 раз, выводя "Итерация номер 0", "Итерация номер 1" и так далее до "Итерация номер 4". 
2. Цикл while
Выполняет блок кода, пока указанное условие истинно. 
Код

```php
<?php
$count = 0;
while ($count < 3) {
    echo "Привет!<br>";
    $count++; // Инкремент счетчика
}
?>
```

Этот цикл выведет "Привет!" три раза, так как условие $count < 3 будет истинным до тех пор, пока переменная $count не станет равна 3. 
3. Цикл do-while
Похож на while, но гарантирует, что код внутри цикла выполнится хотя бы один раз, даже если условие сразу ложно. 
Код

```php
<?php
$i = 10;
do {
    echo "Значение $i<br>";
    $i--;
} while ($i > 11);
?>
```
Здесь цикл выполнится один раз, выведя "Значение 10", и только потом проверит условие $i > 11, которое окажется ложным, после чего цикл завершится. 
4. Цикл foreach
Специально предназначен для перебора элементов массивов и объектов. 
Код

```php
<?php
$fruits = ['Яблоко', 'Банан', 'Вишня'];
foreach ($fruits as $fruit) {
    echo $fruit . "<br>";
}
?>
```

Этот цикл переберет все элементы массива $fruits и выведет каждый из них, каждый на новой строке. 

## Примеры условных конструкций 
В PHP существует несколько видов условных конструкций: if, if...else, if...elseif...else, а также switch и тернарный оператор ?:, которые позволяют выполнять различные блоки кода в зависимости от истинности или ложности определённых условий. 
1. Оператор if
Выполняет блок кода, если условие истинно. 
Код

```php
<?php
$age = 20;
if ($age >= 18) {
    echo "Вы совершеннолетний."; // Этот код выполнится
}
?>
```

2. Оператор if...else
Выполняет один блок кода, если условие истинно, и другой блок, если оно ложно. 
Код

```php
<?php
$temperature = 15;
if ($temperature < 20) {
    echo "Прохладно.";
} else {
    echo "Тепло."; // Этот код выполнится
}
?>
```

3. Оператор if...elseif...else
Позволяет проверить несколько условий последовательно. 
Код

```php
<?php
$score = 85;
if ($score >= 90) {
    echo "Отлично!";
} elseif ($score >= 80) {
    echo "Хорошо!"; // Этот код выполнится
} else {
    echo "Удовлетворительно.";
}
?>
```

4. Оператор switch
Используется, когда нужно выбрать один из множества вариантов для одного значения переменной. 
Код

```php
<?php
$day = "Понедельник";
switch ($day) {
    case "Суббота":
    case "Воскресенье":
        echo "Выходной!";
        break;
    case "Понедельник":
        echo "Рабочий день."; // Этот код выполнится
        break;
    default:
        echo "Неизвестный день.";
}
?>
```

5. Тернарный оператор ?:
Краткая запись для простых условий if...else. 
Код

```php
<?php
$isLoggedIn = true;
$message = $isLoggedIn ? "Привет, пользователь!" : "Пожалуйста, войдите.";
echo $message; // Выведет "Привет, пользователь!"
?>
```

Логические операторы
Для создания более сложных условий используются логические операторы, такие как && (И), || (ИЛИ), ! (НЕ). 
Код

```php
<?php
$hasPermission = true;
$isAdmin = false;

if ($hasPermission && $isAdmin) {
    echo "Полный доступ.";
} elseif (!$hasPermission || $isAdmin) {
    echo "Частичный доступ или вы администратор."; // Этот код выполнится
}
?>
```

# Функции в PHP
В PHP функция — это ==именованный блок кода, который выполняет определённую задачу и может быть вызван многократно для повторного использования==. Она может принимать входные данные (параметры) и возвращать результат, что делает код более модульным, читаемым и упрощает его поддержку. 

Для чего нужны функции?

- **Повторное использование кода:**
    
    Вместо того чтобы писать один и тот же код в нескольких местах программы, можно создать функцию и вызывать её по имени всякий раз, когда требуется выполнить этот код. 
    

- **Модульность:**
    
    Функции помогают разделить программу на небольшие, легко управляемые блоки, каждый из которых отвечает за свою конкретную задачу. 
    

- **Улучшение читаемости:**
    
    Код становится более организованным, так как логические части программы инкапсулированы в функции с понятными именами. 
    

- **Упрощение поддержки:**
    
    Если требуется изменить логику выполнения какого-либо действия, достаточно отредактировать код только в одном месте — внутри функции. 
    

Как работает функция?

1. **1.** **Определение (создание):**
    
    Функция объявляется с помощью ключевого слова `function`, за которым следует имя функции и скобки `()`. Внутри скобок могут быть указаны параметры (входные данные). 
    

- **2.** **Выполнение:**
    
    Функция не выполняется автоматически при загрузке страницы. Она исполняется только тогда, когда её вызывают по имени. 
    

- **3.** **Параметры и аргументы:**
    
    Параметры — это переменные, указанные при объявлении функции, которые получают значения из аргументов, передаваемых при вызове. 
    

- **4.** **Возвращаемое значение:**
    
    Функция может вернуть результат своей работы с помощью оператора `return`. 
    

Пример:
```php
<?php// Определение функции
function greet($name) {
    return "Привет, " . $name . "!"; // Функция возвращает строку
}

// Вызов функции
echo greet("Мир"); // Выведет: Привет, Мир!

// Еще один вызов с другим аргументом
echo "<br>";
echo greet("PHP"); // Выведет: Привет, PHP!?>
```

# ОПП в PHP
**ООП (Объектно-Ориентированное Программирование)** — это подход к программированию, в котором программа представляется в виде совокупности объектов, каждый из которых является экземпляром определенного класса.

**Основные принципы ООП:**

- **Инкапсуляция** — объединение данных и методов в одном объекте
    
- **Наследование** — создание новых классов на основе существующих
    
- **Полиморфизм** — возможность использования одинаковых методов для разных объектов
## Создание классов
**Класс** — это шаблон для создания объектов. Он определяет свойства (переменные) и методы (функции), которые будут у объектов.

```php
class Car {
    // Свойства класса
    public $brand;
    public $color;
    
    // Конструктор (вызывается при создании объекта)
    public function __construct($brand, $color) {
        $this->brand = $brand;
        $this->color = $color;
    }
    
    // Метод класса
    public function startEngine() {
        return "Двигатель {$this->brand} запущен!";
    }
}
```
## Создание нового объекта класса
**Объект** - это экземпляр класса. Создается с помощью ключевого слова `new`
```php
// Создание объектов
$myCar = new Car("Toyota", "красный");
$yourCar = new Car("BMW", "синий");

echo $myCar->brand; // Выведет: Toyota
```
## Обращение к методам и свойствам класса
Обращение происходит через оператор `->`
```php
class User {
    public $name = "Иван";
    
    public function sayHello() {
        return "Привет, меня зовут {$this->name}";
    }
}

$user = new User();

// Обращение к свойству
echo $user->name; // Иван

// Обращение к методу
echo $user->sayHello(); // Привет, меня зовут Иван

// Изменение свойства
$user->name = "Петр";
```
## Public, protected, private
Это модификаторы доступа, которые определяют область видимости свойств и методов:

- **public** — доступен отовсюду (из любого места программы)
    
- **protected** — доступен только внутри класса и его потомков (наследников)
    
- **private** — доступен только внутри самого класса

```php
class Example {
    public $public = "Доступно везде";
    protected $protected = "Доступно в классе и наследниках";
    private $private = "Доступно только в этом классе";
    
    public function showAll() {
        echo $this->public;    // OK
        echo $this->protected; // OK
        echo $this->private;   // OK
    }
}

$obj = new Example();
echo $obj->public;    // OK
// echo $obj->protected; // Ошибка!
// echo $obj->private;   // Ошибка!
```
## Наследование
**Наследование** — это механизм, позволяющий создавать новый класс на основе существующего, перенимая его свойства и методы.
```php
// Родительский класс
class Animal {
    protected $name;
    
    public function __construct($name) {
        $this->name = $name;
    }
    
    public function eat() {
        return "{$this->name} ест";
    }
}

// Дочерний класс (наследует от Animal)
class Dog extends Animal {
    public function bark() {
        return "{$this->name} гавкает";
    }
}

// Использование
$dog = new Dog("Шарик");
echo $dog->eat();  // Шарик ест (метод унаследован)
echo $dog->bark(); // Шарик гавкает (собственный метод)
```
**Ключевое слово `extends`** используется для наследования, а `parent::` для обращения к родительскому классу:
```php
class Cat extends Animal {
    public function __construct($name, $color) {
        parent::__construct($name); // Вызов конструктора родителя
        $this->color = $color;
    }
    
    public function meow() {
        return "{$this->name} мяукает";
    }
}
```
Наследование позволяет создавать иерархии классов и повторно использовать код.

# Интерфейс и его использование
**Интерфейс** — это контракт, который определяет, какие методы должен реализовать класс, но не содержит их реализации.
```php
// Объявление интерфейса
interface Logger {
    public function log($message);
    public function error($message);
}

// Класс реализует интерфейс
class FileLogger implements Logger {
    public function log($message) {
        file_put_contents('log.txt', $message . PHP_EOL, FILE_APPEND);
    }
    
    public function error($message) {
        file_put_contents('error.txt', "ERROR: " . $message . PHP_EOL, FILE_APPEND);
    }
}

// Еще один класс с тем же интерфейсом
class DatabaseLogger implements Logger {
    public function log($message) {
        // Логика сохранения в базу данных
    }
    
    public function error($message) {
        // Логика сохранения ошибки в базу
    }
}

// Использование
function processUser(Logger $logger) {
    $logger->log("Пользователь обработан");
}

$fileLogger = new FileLogger();
$dbLogger = new DatabaseLogger();

processUser($fileLogger); // Работает с любым логгером
processUser($dbLogger);   // Главное - реализация интерфейса
```
**Особенности интерфейсов:**

- Все методы в интерфейсе должны быть `public`
	
- Класс может реализовывать несколько интерфейсов
    
- Интерфейсы могут наследоваться друг от друга

## Трейты и их использование
**Трейты** — это механизм повторного использования кода в PHP. Они позволяют включать методы в классы без наследования.
```php
// Объявление трейта
trait Loggable {
    public function log($message) {
        echo "[" . date('Y-m-d H:i:s') . "] " . $message . PHP_EOL;
    }
}

trait Cacheable {
    protected $cache = [];
    
    public function getFromCache($key) {
        return $this->cache[$key] ?? null;
    }
    
    public function setToCache($key, $value) {
        $this->cache[$key] = $value;
    }
}

// Использование трейтов в классе
class UserService {
    use Loggable, Cacheable;
    
    public function createUser($name) {
        $this->log("Создание пользователя: $name");
        // Логика создания пользователя
        $this->setToCache('last_user', $name);
    }
}

class ProductService {
    use Loggable;
    
    public function createProduct($name) {
        $this->log("Создание продукта: $name");
        // Логика создания продукта
    }
}

// Использование
$userService = new UserService();
$userService->createUser("Иван"); // Использует метод из трейта

$productService = new ProductService();
$productService->createProduct("Телефон"); // Тоже использует трейт
```
**Преимущества трейтов:**

- Избегание проблем множественного наследования
    
- Повторное использование кода
    
- Можно использовать несколько трейтов в одном классе

## Что такое статические методы и свойства?
**Статические методы и свойства** принадлежат классу, а не конкретному объекту. Они доступны без создания экземпляра класса.
```php
class MathOperations {
    // Статическое свойство
    public static $pi = 3.14159;
    
    // Статический метод
    public static function square($number) {
        return $number * $number;
    }
    
    // Обычный метод
    public function cube($number) {
        return $number * $number * $number;
    }
}
```
## Как используются статические методы и свойства?
### Обращение к статическим членам класса:
```php
// Обращение к статическому свойству
echo MathOperations::$pi; // 3.14159

// Вызов статического метода
$result = MathOperations::square(5); // 25

// Неправильно (вызовет ошибку):
// $math = new MathOperations();
// echo $math->pi;
// echo $math->square(5);
```
### Использование внутри класса:
```php
class Database {
    private static $connection = null;
    
    // Статический метод для получения соединения
    public static function getConnection() {
        if (self::$connection === null) {
            self::$connection = new PDO('mysql:host=localhost;dbname=test', 'user', 'pass');
        }
        return self::$connection;
    }
    
    // Статический метод для запроса
    public static function query($sql) {
        return self::getConnection()->query($sql);
    }
}

// Использование без создания объекта
$users = Database::query("SELECT * FROM users");
```
### Практический пример с счетчиком:
```php
class Counter {
    private static $count = 0;
    
    public function __construct() {
        self::$count++;
    }
    
    public static function getCount() {
        return self::$count;
    }
    
    public function __destruct() {
        self::$count--;
    }
}

// Использование
echo Counter::getCount(); // 0

$obj1 = new Counter();
$obj2 = new Counter();
$obj3 = new Counter();

echo Counter::getCount(); // 3

unset($obj2);
echo Counter::getCount(); // 2
```
### Ключевое слово `self` vs `static`:
```php
class ParentClass {
    public static function getClass() {
        return self::class; // Всегда вернет ParentClass
    }
    
    public static function getLateClass() {
        return static::class; // Вернет имя текущего класса
    }
}

class ChildClass extends ParentClass {}

echo ParentClass::getClass(); // ParentClass
echo ChildClass::getClass();  // ParentClass (потому что self)

echo ParentClass::getLateClass(); // ParentClass
echo ChildClass::getLateClass();  // ChildClass (потому что static)
```
**Основные особенности статических методов:**

- Не имеют доступа к `$this`
    
- Могут обращаться только к статическим свойствам и методам
    
- Вызываются через `::` вместо `->`
    
- Полезны для утилитарных функций и шаблона Singleton

# Встроенные функции в php
## Математические
abs() — возвращает абсолютное значение (модуль числа). 

sqrt() — находит квадратный корень числа. 

pow() — возводит число в заданную степень. 

round() — округляет число по правилам математического округления. 

ceil() — округляет дробь в большую сторону. 

floor() — округляет дробь в меньшую сторону. 

## Строковые
strlen() — возвращает длину строки. 

strpos() — возвращает позицию первого вхождения подстроки. 

substr() — возвращает подстроку (часть строки). 

str_replace() — заменяет все вхождения строки поиска на строку замены. 

trim() — удаляет пробелы (или другие символы) из начала и конца строки. 

## Массивы
count() — подсчитывает количество элементов массива. 

array_push() — добавляет один или несколько элементов в конец массива. 

array_pop() — извлекает последний элемент массива. 

array_merge() — объединяет два или более массива в один. 

array_chunk() — разбивает массив на несколько частей. 

# Базы данных
mysqli_query() — выполняет запрос к базе данных, возвращает FALSE в случае неудачи.

mysqli_fetch_all() — выбирает все строки из результирующего набора и помещает их в ассоциативный массив.

mysqli_num_rows() — получает число строк в результирующей выборке.

mysqli_affected_rows() — получает число строк, затронутых предыдущей операцией (INSERT, UPDATE, REPLACE или DELETE).

```php
<?php
// интерфейсы задают правила для написания классов
interface Pers { 
  function sayHello();
}

// заготовленные функции(методы) для использования в классах
trait Message {
  function messageTest ($text) {
      echo $text;
    }
}

class Person implements Pers
{ 
  use Message;
    
    public $name, $age;
    static $retirenmentAge = 65;
    
    function __construct($name, $age)
    {
        $this->name = $name;
        $this->age = $age;
    }
    
    function sayHello()
    {
        echo "Привет, меня зовут $this->name<br>";
    }
    
    static function printPerson($person)
    {
        echo "Имя: $person->name Возраст: $person->age<br>";
    }
    
    function checkAge()
    {
        if($this->age >= self::$retirenmentAge)
            echo "Пора на пенсию<br>";
        else
            echo "До пенсии еще " . (Person::$retirenmentAge - $this->age) . " лет<br>";
    }
}

$tom = new Person("Tom", 36);
$tom->checkAge();
Person::printPerson($tom);
Person::messageTest("<br> Hello World!");
?>
```

# Подключиться к БД через PDO (рекомендуется)
```php
new PDO("mysql:host=адрес_сервера;port=номер_порта;dbname=имя_базы_данных", "имя_пользователя", "пароль")
```

```php
<?php
try {
    // подключаемся к серверу
    $conn = new PDO("mysql:host=localhost", "root", "mypassword");
}
catch (PDOException $e) {
    echo "Connection failed: " . $e->getMessage();
}
?>
```

```php
$conn->exec("CREATE DATABASE test");
```

```php
$conn->query("SELECT * FROM USERS");
```

```php
<?php
try {
    $conn = new PDO("mysql:host=localhost;dbname=test", "root", "mypassword");
   
    $result = $conn->query( "SELECT * FROM Users");
    echo "<table><tr><th>Id</th><th>Name</th><th>Age</th></tr>";
    while($row = $result->fetch()){
        echo "<tr>";
            echo "<td>" . $row["id"] . "</td>";
            echo "<td>" . $row["name"] . "</td>";
            echo "<td>" . $row["age"] . "</td>";
        echo "</tr>";
    }
    echo "</table>";
}
catch (PDOException $e) {
    echo "Database error: " . $e->getMessage();
}
?>
```

```php
// Используется для закрытия соединения PDO
$conn = null;
 // Используется для закрытия соединения mysqli
mysqli_close($conn);
```

```php
try {
    //...
} catch (Exception $e) {
    //...
}
```
# Суперглобальные переменные в PHP

$GLOBALS - Ассоциативный массив (array), который содержит ссылки на каждую переменную, которую в текущий момент определили в глобальной области видимости скрипта.

$_SERVER - Переменная $_SERVER — массив (array), который содержит информацию о заголовках, путях и расположениях скриптов. Записи в этом массиве создаются веб-сервером, поэтому нет гарантии, что каждый веб-сервер будет предоставлять каждую из этих переменных;

$_GET - Ассоциативный массив переменных, переданных скрипту через параметры URL (известные также как строка запроса). Обратите внимание, что массив не только заполняется для GET-запросов, а скорее для всех запросов со строкой запроса.

$_POST - Ассоциативный массив данных, переданных скрипту через HTTP методом POST при использовании application/x-www-form-urlencoded или multipart/form-data в заголовке Content-Type запроса HTTP.

$_FILES - Ассоциативный массив (array) элементов, загруженных в текущий скрипт через метод HTTP POST. Структура этого массива описана в разделе Загрузка файлов методом POST.

$_COOKIE - Ассоциативный массив (array) значений, переданных скрипту через HTTP Cookies.

$_SESSION - Ассоциативный массив, содержащий переменные сессии, которые доступны для текущего скрипта. Смотрите документацию по функциям сессии для получения дополнительной информации.

$_REQUEST - Ассоциативный массив (array), который по умолчанию содержит данные переменных $_GET, $_POST и $_COOKIE.

$_ENV - Эти значения импортируются в глобальное пространство имён PHP из системных переменных окружения, в котором запущен парсер PHP. Большинство значений передаётся из командной оболочки, под которой запущен PHP.


# Пространство имён (namespace)
Пространства имен позволяют избежать конфликта имен и сгруппировать функционал. Внутри пространства имен могут быть размещены классы, интерфейсы, функции и константы.

Если конструкция (например, класс или функция) определена вне любого пространства имен, то считается, что она расположена в глобальном пространстве имен.

Для создания пространства имен применяется директива namespace, после которой идет название пространства имен.

```php
namespace test;
//php код (класс)
```

Обычно названия пространств указываются в нижнем регистре. Все, что расположено ниже этой директивы, относится к пространству имен "test". То есть класс принадлежит пространству имен test.

Определение пространства имен должно быть расположено выше любого другого кода или разметки html. 

Обращение к пространству имен
Для обращения к конструкциям из пространства имен перед названием конструкции через слеш указывается ее пространство имен.

```php
namespace test2;
include "название файла где было инициировано пространство имён";
$tom = new \test\название_класса_внутри_namespace("Tom");
echo $tom->name;
```
Если конструкции одного пространства имен используются в другом пространстве имен (в том числе в глобальном пространстве имен), то перед названием конструкции указывается название ее пространства имен. Так, поскольку класс расположен в другом пространстве имен - "test", то перед названием класса указываем его полное имя с учетом его пространства имен.

```php
$tom = new \base\Person("Tom");
```

## Вложенные пространства имен
```php
<?php
namespace base\classes;
class Person
{
    public $name;
    function __construct($name) { $this->name = $name; }
}
?>
```
Класс Person определен в пространстве имен \base\classes\. То есть теперь для обращения к классу Person в другом пространстве имен надо указывать \base\classes\Person.

# Сессии в php
**Начало сессии** - session_start()
**Создание идентификатора** - PHPSESSID (уникальный ID)
**Хранение данных** - в суперглобальном массиве $_SESSION
**Сохранение на сервере** - обычно в файлах в /tmp/
```php
<?php
// Начинаем сессию
session_start();

// Сохраняем данные в сессию
$_SESSION['username'] = 'ivan';
$_SESSION['login_time'] = time();

// Читаем данные из сессии
echo "Привет, " . $_SESSION['username'];
?>

<?php
// 1. Инициализация
session_start();

// 2. Работа с данными
$_SESSION['counter'] = ($_SESSION['counter'] ?? 0) + 1;

// 3. Уничтожение (при выходе)
// session_destroy();
?>
```