[[13.01.25 - Цели и задачи оптимизации|предыдущяя тема]]
# Оптимизация статики

Один из наиболее эффективных, но редко используемых способов увеличения производительности состоит в том, чтобы понять, как браузер анализирует и хранит статику. Современные браузеры весьма успешно анализируют приоритет ресурсов прямо во время их парсинга. И именно здесь появляется ==критический запрос==.

Запрос является критическим, если в нем содержится статика, необходимая для рендеринга контента в рамках пользовательского рабочего окна.

Для большинства сайтов это будет HTML, стили, логотип, шрифты и, возможно, изображения. 

Но на деле оказывается, что в это же время помимо них запрашиваются множество других, второстепенных вещей (JS, трек-коды, реклама и т.д.).

Можно контролировать это поведение, указывая приоритет подгрузки статики.

<link rel='preload' href='critical.css' as='style'>

Для отслеживания приоритетов запросов:
	- [https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf](https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf)
	- [https://developers.google.com/web/tools/lighthouse/audits/critical-request-chains](https://developers.google.com/web/tools/lighthouse/audits/critical-request-chains)

# Оптимизация изображений

Картинки составляют львиную долю материалов веб-страницы, поэтому их оптимизация может в значительной степени повлиять на улучшение производительности пользовательского интерфейса. Существует множество стратегий и инструментов для устранения лишних байтов.

Главный вопрос: "Существенна ли эта картинка для передачи идеи или достижения эффекта, которого я добиваюсь?"

Если есть возможность обойтись без нее, вы сэкономите не только на пропускной способности, но и на запросах.

В некоторых случаях один и тот же результат достижим несколькими способами. CSS богат художественными инструментами: тени, градиенты, анимации, фигуры. Всё это позволяет надлежащим образом стилизованным элементам DOM служит достойной заменой статическим изображениям.

# Выбор правильного формата изображений

Если избежать использования статики невозможно, важно правильно определить для нее наиболее подходящий формат. 

Первая ступень - выбор между вектором и растром.
	- Вектор: не зависит от разрешения, как правило значительно компактнее. (лого, иконки, геометрические картинки)
	- Растр: подходит для высоко детализированных изображений. (фото)

После принятия этого решения, вам откроется широкий выбор: JPEG, GIF, PNG-8, PNG-24, или новейшие форматы, такие как WEBP или JPEG-XR. 
	- JPEG: для изображений с богатой цветовой палитрой (фото)
	- PNG-8: для изображений с малым количеством цветовой палитры
	- PNG-24: для изображений с прозрачными участками
	- GIF: для анимаций

# Оптимизация инструментами и алгоритмами

Следующая (ключевая) ступень - оптимизация.

SVG должен быть сжат. (SVGO, SVGOMG)

Можно сжать с помощью GZIP на стороне сервера.

Для других форматов - ImageOptim.

От Goggle - Guetzi (открытый алгоритм, происходящий из прошлого опыта с WebP и Zopfi).
Сжатие JPEG до 35%.
Недостаток - низкая производительность.

[https://squoosh.app/](https://squoosh.app/)
[https://tinypng.com/](https://tinypng.com/)
[https://github.com/svg/svgo](https://github.com/svg/svgo)
[https://imageoptim.com/mac](https://imageoptim.com/mac)
[https://research.google/blog/announcing-guetzli-a-new-open-source-jpeg-encoder/](https://research.google/blog/announcing-guetzli-a-new-open-source-jpeg-encoder/)

# Оптимизация шрифтов

Шрифты - главный враг производительности.

## Выбор правильного шрифта

Существует 4 веб-формата:
	- EOT
	- TTF
	- WOFF
	- WOFF2

TTF, WOFF - чаще всего используются (поддерживают 90% сайтов)

WOFF2 - оптимальный.

**Преимущество** - подразумевает ряд кастомных препроцессорных и сжимающих алгоритмов, что позволяет уменьшить итоговый вес файла на 30% и существенно повысить возможности парсинга.

# Оптимизация JS

## Избавьтесь от лишних зависимостей

Инструменты:
	1. webpack-bundle-analyzer
	2. bundle buddy

Визуальные инструменты позволяют обнаружить дублирование кода, самые большие затраты производительности, ненужные зависимости. 

В VS Code и Atom есть расширение Inport Cost, делающее вес импортируемого пакета более наглядным.