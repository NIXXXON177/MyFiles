<style>  
	.alert {  
		padding: 15px;  
		border: 1px solid #d6e9c6;  
		border-radius: 4px;  
		color: #3c763d;  
		background-color: #dff0d8;  
	}  
</style>
 
<script>  
let div = document.createElement('div');  
div.className = "alert";  
div.innerHTML = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";
 
document.body.append(div);  
</script>
 
Вот методы для различных вариантов вставки:
	- node.append(...nodes or strings) – добавляет узлы или строки в конец node,
	- node.prepend(...nodes or strings) – вставляет узлы или строки в начало node,
	- node.before(...nodes or strings) –- вставляет узлы или строки до node,
	- node.after(...nodes or strings) –- вставляет узлы или строки после node,
	- node.replaceWith(...nodes or strings) –- заменяет node заданными узлами или строками.
 
Вот пример использования этих методов, чтобы добавить новые элементы в список и текст до/после него:
 
<ol id="ol">  
	<li>0</li>  
	<li>1</li>  
	<li>2</li>  
</ol>
 
<script>  
ol.before('before'); // вставить строку "before" перед <ol>  
ol.after('after'); // вставить строку "after" после <ol>
 
let liFirst = document.createElement('li');  
liFirst.innerHTML = 'prepend';  
ol.prepend(liFirst); // вставить liFirst в начало <ol>
 
let liLast = document.createElement('li');  
liLast.innerHTML = 'append';  
ol.append(liLast); // вставить liLast в конец <ol>  
</script>
 
before
	1. prepend
	2. 0
	3. 1
	4. 2
	5. append
after

 ![40 L ) ol .before ol . prepend 'li»1'/Li» ol . append (..modes or strings) ](cache/Exported%20image%2020250112225555-0.png)  

before  
<ol id="ol">  
	<li>prepend</li>  
	<li>0</li>  
	<li>1</li>  
	<li>2</li>  
	<li>append</li>  
</ol>  
after
 
## insertAdjacentHTML/Text/Element
 
С этим может помочь другой, довольно универсальный метод: elem.insertAdjacentHTML(where, html).
 
Первый параметр – это специальное слово, указывающее, куда по отношению к elem производить вставку. Значение должно быть одним из следующих:
	- "beforebegin" – вставить html непосредственно перед elem,
	- "afterbegin" – вставить html в начало elem,
	- "beforeend" – вставить html в конец elem,
	- "afterend" – вставить html непосредственно после elem.
 
Второй параметр – это HTML-строка, которая будет вставлена именно «как HTML».
 
Например:
 
<div id="div"></div>  
<script>  
div.insertAdjacentHTML('beforebegin', '<p>Привет</p>');  
div.insertAdjacentHTML('afterend', '<p>Пока</p>');  
</script>
 
…Приведёт к:
 
<p>Привет</p>  
<div id="div"></div>  
<p>Пока</p>

 ![betorebegln atrerbegln ol . , html) betoreend at terend ](cache/Exported%20image%2020250112225558-1.png)  

Мы можем легко заметить сходство между этой и предыдущей картинкой. Точки вставки фактически одинаковые, но этот метод вставляет HTML.
 
У метода есть два брата:
	- elem.insertAdjacentText(where, text) – такой же синтаксис, но строка text вставляется «как текст», вместо HTML,
	- elem.insertAdjacentElement(where, elem) – такой же синтаксис, но вставляет элемент elem.
 
Они существуют, в основном, чтобы унифицировать синтаксис. На практике часто используется только insertAdjacentHTML. Потому что для элементов и текста у нас есть методы append/prepend/before/after – их быстрее написать, и они могут вставлять как узлы, так и текст.
 
Так что, вот альтернативный вариант показа сообщения:
 
\\<style>  
	.alert {  
		padding: 15px;  
		border: 1px solid #d6e9c6;  
		border-radius: 4px;  
		color: #3c763d;  
		background-color: #dff0d8;  
	}  
</style>
 
<script>  
document.body.insertAdjacentHTML("afterbegin", `<div class="alert">  
<strong>Всем привет!</strong> Вы прочитали важное сообщение.  
</div>`);  
</script>
 
## Удаление узлов
 
Для удаления узла есть методы node.remove().
 
Например, сделаем так, чтобы наше сообщение удалялось через секунду:
 
<style>  
	.alert {  
		padding: 15px;  
		border: 1px solid #d6e9c6;  
		border-radius: 4px;  
		color: #3c763d;  
		background-color: #dff0d8;  
	}  
</style>
 
<script>  
let div = document.createElement('div');  
div.className = "alert";  
div.innerHTML = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";
 
document.body.append(div);  
setTimeout(() => div.remove(), 1000);  
</script>
 
Если нам нужно переместить элемент в другое место – нет необходимости удалять его со старого.
 
Все методы вставки автоматически удаляют узлы со старых мест.
 
Например, давайте поменяем местами элементы:
 
<div id="first">Первый</div>  
<div id="second">Второй</div>  
<script>  
// нет необходимости вызывать метод remove  
second.after(first); // берёт #second и после него вставляет #first  
</script>
 
## Клонирование узлов: cloneNode
 
Как вставить ещё одно подобное сообщение?
 
Мы могли бы создать функцию и поместить код туда. Альтернатива – клонировать существующий div и изменить текст внутри него (при необходимости).
 
Иногда, когда у нас есть большой элемент, это может быть быстрее и проще.
 
Вызов elem.cloneNode(true) создаёт «глубокий» клон элемента – со всеми атрибутами и дочерними элементами. Если мы вызовем elem.cloneNode(false), тогда клон будет без дочерних элементов.
 
Пример копирования сообщения:
 
<style>  
	.alert {  
		padding: 15px;  
		border: 1px solid #d6e9c6;  
		border-radius: 4px;  
		color: #3c763d;  
		background-color: #dff0d8;  
	}  
</style>
 
<div class="alert" id="div">  
	<strong>Всем привет!</strong> Вы прочитали важное сообщение.  
</div>
 
<script>  
let div2 = div.cloneNode(true); // клонировать сообщение  
div2.querySelector('strong').innerHTML = 'Всем пока!'; // изменить клонированный элемент
 
div.after(div2); // показать клонированный элемент после существующего div  
</script>
 
## DocumentFragment
 
DocumentFragment является специальным DOM-узлом, который служит обёрткой для передачи списков узлов.
 
Мы можем добавить к нему другие узлы, но когда мы вставляем его куда-то, он «исчезает», вместо него вставляется его содержимое.
 
Например, getListContent ниже генерирует фрагмент с элементами <li></li>, которые позже вставляются в <ul></ul>:
 
<ul id="ul"></ul>
 
<script>  
function getListContent() {  
	let fragment = new DocumentFragment();
	 
	for(let i=1; i<=3; i++) {  
		let li = document.createElement('li');  
		li.append(i);  
		fragment.append(li);  
	}
	 
	return fragment;  
}
 
ul.append(getListContent()); // (*)  
</script>
 
Обратите внимание, что на последней строке с (*) мы добавляем DocumentFragment, но он «исчезает», поэтому структура будет:
 
<ul>  
	<li>1</li>  
	<li>2</li>  
	<li>3</li>  
</ul>
 
DocumentFragment редко используется. Зачем добавлять элементы в специальный вид узла, если вместо этого мы можем вернуть массив узлов? Переписанный пример:
 
<ul id="ul"></ul>
 
<script>  
function getListContent() {  
	let result = [];
	 
	for(let i=1; i<=3; i++) {  
		let li = document.createElement('li');  
		li.append(i);  
		result.push(li);  
	}
 
	return result;  
}
 
ul.append(...getListContent()); // append + оператор "..." = друзья!  
</script>

---

Мы упоминаем DocumentFragment в основном потому, что он используется в некоторых других областях, например, для элемента template, который мы рассмотрим гораздо позже.

# Итого
 
Методы для создания узлов:
	- document.createElement(tag) – создаёт элемент с заданным тегом,
	- document.createTextNode(value) – создаёт текстовый узел (редко используется),
	- elem.cloneNode(deep) – клонирует элемент, если deeptrue, то со всеми дочерними элементами.
 
Вставка и удаление:
	- node.append(...nodes or strings) – вставляет в node в конец,
	- node.prepend(...nodes or strings) – вставляет в node в начало,
	- node.before(...nodes or strings) – вставляет прямо перед node,
	- node.after(...nodes or strings) – вставляет сразу после node,
	- node.replaceWith(...nodes or strings) – заменяет node.
	- node.remove() – удаляет node.
 
Устаревшие методы:
	- parent.appendChild(node)
	- parent.insertBefore(node, nextSibling)
	- parent.removeChild(node)
	- parent.replaceChild(newElem, node)
 
Все эти методы возвращают node.
 
Если нужно вставить фрагмент HTML, то elem.insertAdjacentHTML(where, html) вставляет в зависимости от where:
	- "beforebegin" – вставляет html прямо перед elem,
	- "afterbegin" – вставляет html в elem в начало,
	- "beforeend" – вставляет html в elem в конец,
	- "afterend" – вставляет html сразу после elem.
 
Также существуют похожие методы elem.insertAdjacentText и elem.insertAdjacentElement, они вставляют текстовые строки и элементы, но они редко используются.
 
Чтобы добавить HTML на страницу до завершения её загрузки:
	- document.write(html)
 
После загрузки страницы такой вызов затирает документ. В основном встречается в старых скриптах.