Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.
 
При копировании переменной объекта копируется ссылка, но сам объект не дублируется.
 
>>> let user = { name: "John" };
>>> let admin = user; // копируется ссылка
 
Теперь у нас есть две переменные, каждая из которых содержит ссылку на один и тот же объект.

 ![Exported image](cache/Exported%20image%2020250112225522-0.png)  

>>> let user = { name: 'John' };
>>> let admin = user;
>>> admin.name = 'Pete'; // изменено по ссылке из переменной "admin" 
>>> alert(user.name); // 'Pete', изменения видны по ссылке из переменной "user"
 
# Сравнение по ссылке
 
Два объекта равны только в том случае, если это один и тот же объект.
 
Например, здесь a и b ссылаются на один и тот же объект, поэтому они равны:
 
>>> let a = {};  
>>> let b = a; // копирование по ссылке
>>>  
>>> alert( a == b ); // true, обе переменные ссылаются на один и тот же объект  
>>> alert( a === b ); // true
 
# Клонирование и объединение, Object.assign
 
>>> let user = {  
>>> name: "John",  
>>> age: 30  
>>> };
>>>  
>>> let clone = {}; // новый пустой объект
>>>  
>>> // давайте скопируем все свойства user в него  
>>> for (let key in user) {  
>>> clone[key] = user[key];  
>>> }
>>>  
>>> // теперь clone это полностью независимый объект с тем же содержимым  
>>> clone.name = "Pete"; // изменим в нём данные
>>>  
>>> alert( user.name ); // все ещё John в первоначальном объекте
 
Также мы можем использовать для этого метод Object.assign.
 
## Синтаксис:
 
>>> Object.assign(dest, [src1, src2, src3...])
 
- Первый аргумент dest — целевой объект.
- Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
- Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
- Возвращает объект dest.
    
>>> let user = { name: "John" };
>>>  
>>> let permissions1 = { canView: true };  
>>> let permissions2 = { canEdit: true };
>>>  
>>> // копируем все свойства из permissions1 и permissions2 в user  
>>> Object.assign(user, permissions1, permissions2);
>>>  
>>> // теперь user = { name: "John", canView: true, canEdit: true }
 
Если скопированное имя свойства уже существует, оно будет перезаписано:
 
>>> let user = { name: "John" };
>>>  
>>> Object.assign(user, { name: "Pete" });
>>>  
>>> alert(user.name); // теперь user = { name: "Pete" }
 
Мы также можем использовать Object.assign для замены цикла for..in для простого клонирования:
 
>>> let user = {  
>>> 	name: "John",  
>>> 	age: 30  
>>> };
>>>  
>>> let clone = Object.assign({}, user);
 
# Итого
 
Объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не «значение объекта», а «ссылку» (адрес в памяти) на это значение. Таким образом, копирование такой переменной или передача её в качестве аргумента функции копирует эту ссылку, а не сам объект.
 
Все операции с использованием скопированных ссылок (например, добавление/удаление свойств) выполняются с одним и тем же объектом.
 
Чтобы создать «реальную копию» (клон), мы можем использовать Object.assign для так называемой «поверхностной копии» (вложенные объекты копируются по ссылке) или функцию «глубокого клонирования», такую как _.cloneDeep(obj).