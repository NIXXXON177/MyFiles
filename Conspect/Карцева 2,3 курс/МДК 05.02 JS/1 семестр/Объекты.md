## Синтаксис
 
- object = {}
- object = new Object ()
- object = Object.create (prototype \[, propertiesObject])
- object.key = значение
- object \["key"] = значение
- object \[Символ ()] = значение
- object = {key1: value1, "key2": value2, 'key3': value3}
- object = {conciseMethod () {...}}
- object = {\[computed () + "key"]: значение}
- Object.defineProperty (obj, propertyName, propertyDescriptor)
- property_desc = Object.getOwnPropertyDescriptor (obj, propertyName)
- Object.freeze (OBJ)
- Object.seal (OBJ)   
   

## Параметры
 ![Exported image](cache/Exported%20image%2020250112225550-0.png)  

## Замечания
 
Объекты представляют собой коллекции пар ключ-значение или свойства. Ключами могут быть String s или Symbol s, а значения - либо примитивы (числа, строки, символы), либо ссылки на другие объекты.
 
В JavaScript значительное количество значений - это объекты (например, функции, массивы) или примитивы, которые ведут себя как неизменные объекты (числа, строки, логические значения). Их свойства или свойства их prototype могут быть доступны с использованием точечной ( obj.prop ) или скобки ( obj\['prop'] ). Заметными исключениями являются специальные значения undefined и null .
 
Объекты хранятся по ссылке в JavaScript, а не по значению. Это означает, что при копировании или передаче в качестве аргументов функций, «копия» и оригинал являются ссылками на один и тот же объект, а изменение их свойств изменит одно и то же свойство другого. Это не относится к примитивам, которые неизменяемы и передаются по значению.
 
## Object.keys
 
>>> var obj = {  
>>> 	a: "hello",  
>>> 	b: "this is",  
>>> 	c: "javascript!"  
>>> };
>>>  
>>> var keys = Object.keys(obj);
>>>  
>>> console.log(keys); // ["a", "b", "c"]
 
## Неглубокое клонирование
 
Функция Object.assign() может использоваться для копирования всех перечислимых свойств из существующего экземпляра Object в новый.
 
>>> const existing = { a: 1, b: 2, c: 3 };
>>> const clone = Object.assign({}, existing);
 
Сюда входят свойства Symbol в дополнение к String .
 
Объект rest / spread destructuring, который в настоящее время является предложением этапа 3, обеспечивает еще более простой способ создания неглубоких клонов экземпляров Object:
 
>>> const existing = { a: 1, b: 2, c: 3 };
>>> const { ...clone } = existing;
 
Если вам нужно поддерживать более старые версии JavaScript, наиболее совместимым способом клонирования объекта является ручное повторение его свойств и фильтрация унаследованных с использованием .hasOwnProperty() .
 
>>> var existing = { a: 1, b: 2, c: 3 };
>>>  
>>> var clone = {};  
>>> for (var prop in existing) {  
>>> 	if (existing.hasOwnProperty(prop)) {  
>>> 		clone[prop] = existing[prop];  
>>> 	}  
>>> }
 
## Object.defineProperty
 
Это позволяет нам определить свойство в существующем объекте, используя дескриптор свойства.
 
>>> var obj = { };
>>>  
>>> Object.defineProperty(obj, 'foo', { value: 'foo' });
>>>  
>>> console.log(obj.foo);
>>>  
>>> Консольный выход
>>>  
>>> Foo
 
Object.defineProperty можно вызвать со следующими параметрами:
 
>>> Object.defineProperty(obj, 'nameOfTheProperty', {  
>>> 	value: valueOfTheProperty,  
>>> 	writable: true, // if false, the property is read-only  
>>> 	configurable : true, // true means the property can be changed later  
>>> 	enumerable : true // true means property can be enumerated such as in a for..in loop  
>>> });
 
Object.defineProperties позволяет вам определять сразу несколько свойств.
 
>>> var obj = {};  
>>> Object.defineProperties(obj, {  
>>> 	property1: {  
>>> 	value: true,  
>>> 	writable: true  
>>> 	},  
>>> 	property2: {  
>>> 	value: 'Hello',  
>>> 	writable: false  
>>> 	}  
>>> });
 
## Свойство только для чтения
 
Используя дескрипторы свойств, мы можем сделать свойство только для чтения, и любая попытка изменить его значение будет терпеть неудачно, значение не будет изменено, и никакая ошибка не будет выбрана.
 
writable свойство в дескрипторе свойства указывает, может ли это свойство быть изменено или нет.
 
>>> var a = { };
>>>  
>>> Object.defineProperty(a, 'foo', { value: 'original', writable: false });
>>>  
>>> a.foo = 'new';
>>>  
>>> console.log(a.foo);
>>>  
>>> Консольный выход
>>>  
>>> оригинал
 
## Свойства Accesor (получить и установить)
 
Рассматривайте свойство как комбинацию из двух функций: одну для получения значения из нее, а другую для установки значения в ней.
 
Свойство get дескриптора свойства - это функция, которая будет вызываться для извлечения значения из свойства.
 
Свойство set также является функцией, оно будет вызываться, когда ему присвоено значение, а новое значение будет передано в качестве аргумента.
 
Вы не можете назначить value или writable дескриптор, который get или set
 
>>> var person = { name: "John", surname: "Doe"};  
>>> Object.defineProperty(person, 'fullName', {  
>>> 	get: function () {  
>>> 		return this.name + " " + this.surname;  
>>> 	},  
>>> 	set: function (value) {  
>>> 		\[this.name, this.surname] = value.split(" ");  
>>> 	}  
>>> });
>>>  
>>> console.log(person.fullName); // -> "John Doe"
>>>  
>>> person.surname = "Hill";  
>>> console.log(person.fullName); // -> "John Hill"
>>>  
>>> person.fullName = "Mary Jones";  
>>> console.log(person.name) // -> "Mary"
 
## Массивы - объекты
 
Предположим, мы создали следующий объект, который имеет некоторые свойства, которые вы ожидаете увидеть в массиве.
 
>>> var anObject = {  
>>> 	foo: 'bar',  
>>> 	length: 'interesting',  
>>> 	'0': 'zero!',  
>>> 	'1': 'one!'  
>>> };
 
Затем мы создадим массив.
 
>>> var anArray = \['zero.', 'one.'];
 
Теперь обратите внимание, как мы можем проверить как объект, так и массив таким же образом.
 
>>> console.log(anArray\[0], anObject\[0]); // outputs: zero. zero!  
>>> console.log(anArray\[1], anObject\[1]); // outputs: one. one!  
>>> console.log(anArray.length, anObject.length); // outputs: 2 interesting  
>>> console.log(anArray.foo, anObject.foo); // outputs: undefined bar
 
## Остановка объекта / распространение (...)
 
Распространение объектов - это просто синтаксический сахар для Object.assign({}, obj1, ..., objn);
 
Это делается с помощью оператора ... :
 
>>> let obj = { a: 1 };
>>>  
>>> let obj2 = { ...obj, b: 2, c: 3 };
>>>  
>>> console.log(obj2); // { a: 1, b: 2, c: 3 };
 
Поскольку Object.assign делает мелкое слияние, а не глубокое слияние.
 
>>> let obj3 = { ...obj, b: { c: 2 } };
>>>  
>>> console.log(obj3); // { a: 1, b: { c: 2 } };
 
## Значение полей и их значения по умолчанию
 
configurable , enumerable и writable :
	- Все эти ключи по умолчанию имеют значение false .
	- configurable true тогда и только тогда, когда тип этого дескриптора свойства может быть изменен и если свойство может быть удалено из соответствующего объекта.
	- enumerable true тогда и только тогда, когда это свойство появляется при перечислении свойств на соответствующем объекте.
	- writable true тогда и только тогда, когда значение, связанное с этим свойством, может быть изменено с помощью оператора присваивания.
 
get и set :
	- Эти ключи по умолчанию undefined .
	- get - это функция, которая служит в качестве getter для свойства или undefined если нет геттера. Возврат функции будет использоваться как значение свойства.
	- set - это функция, которая служит средством настройки для свойства или undefined если нет сеттера. Функция получит в качестве единственного аргумента новое значение, которое присваивается свойству.
 
value :
	- Этот ключ по умолчанию undefined .
	- Значение, связанное с этим свойством. Может быть любым допустимым значением JavaScript (число, объект, функция и т. Д.).