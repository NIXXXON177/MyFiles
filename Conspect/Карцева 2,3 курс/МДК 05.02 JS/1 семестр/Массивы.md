# Объявление

Существует два варианта синтаксиса для создания пустого массива:
	let arr = new Array();
	let arr = [];

Мы можем получить элемент, указав его номер в квадратных скобках:
	let fruits = ["Яблоко", "Апельсин", "Слива"];
	alert( fruits[0] ); // Яблоко
	alert( fruits[1] ); // Апельсин
	alert( fruits[2] ); // Слива

Допустим, нам нужен последний элемент массива.

Некоторые языки программирования позволяют использовать отрицательные индексы для той же цели, как-то так: fruits[-1].

Однако, в JavaScript такая запись не сработает. Её результатом будет undefined, поскольку индекс в квадратных скобках понимается буквально.

Мы можем явно вычислить индекс последнего элемента, а затем получить к нему доступ вот так: fruits[fruits.length - 1].
	let fruits = ["Apple", "Orange", "Plum"];
	alert( fruits[fruits.length-1] ); // Plum

Немного громоздко, не так ли? Нам нужно дважды написать имя переменной.

К счастью, есть более короткий синтаксис: fruits.at(-1):
	let fruits = ["Apple", "Orange", "Plum"];
	// то же самое, что и fruits[fruits.length-1]
	alert( fruits.at(-1) ); // Plum

# Методы pop/push, shift/unshift

Очередь – один из самых распространённых вариантов применения массива. В области компьютерных наук так называется упорядоченная коллекция элементов, поддерживающая два вида операций:
	- push добавляет элемент в конец.
	- shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.

Массивы поддерживают обе операции.

На практике необходимость в этом возникает очень часто. Например, очередь сообщений, которые надо показать на экране.

Существует и другой вариант применения для массивов – структура данных, называемая стек.

Она поддерживает два вида операций:
	- push добавляет элемент в конец.
	- pop удаляет последний элемент.

Таким образом, новые элементы всегда добавляются или удаляются из «конца».

Примером стека обычно служит колода карт: новые карты кладутся наверх и берутся тоже сверху.

Массивы в JavaScript могут работать и как очередь, и как стек. Мы можем добавлять/удалять элементы как в начало, так и в конец массива.

В компьютерных науках структура данных, делающая это возможным, называется двусторонняя очередь.

### pop

Удаляет последний элемент из массива и возвращает его:
	let fruits = ["Яблоко", "Апельсин", "Груша"];
	alert( fruits.pop() ); // удаляем "Груша" и выводим его
	alert( fruits ); // Яблоко, Апельсин

И fruits.pop() и fruits.at(-1) возвращают последний элемент массива, но fruits.pop() также изменяет массив, удаляя его.

### push

Добавляет элемент в конец массива:
	let fruits = ["Яблоко", "Апельсин"];
	fruits.push("Груша");
	alert( fruits ); // Яблоко, Апельсин, Груша

Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....

## Методы, работающие с началом массива:

### shift

Удаляет из массива первый элемент и возвращает его:
	let fruits = ["Яблоко", "Апельсин", "Груша"];
	alert( fruits.shift() ); // удаляем Яблоко и выводим его
	alert( fruits ); // Апельсин, Груша

### unshift

Добавляет элемент в начало массива:
	let fruits = ["Апельсин", "Груша"];
	fruits.unshift('Яблоко');
	alert( fruits ); // Яблоко, Апельсин, Груша

Методы push и unshift могут добавлять сразу несколько элементов:
	let fruits = ["Яблоко"];
	fruits.push("Апельсин", "Груша");
	fruits.unshift("Ананас", "Лимон");
	// ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
	alert( fruits );

# Добавление/удаление элементов

Мы уже знаем методы, которые добавляют и удаляют элементы из начала или конца:
	arr.push(...items) – добавляет элементы в конец,
	arr.pop() – извлекает элемент из конца,
	arr.shift() – извлекает элемент из начала,
	arr.unshift(...items) – добавляет элементы в начало.

### splice

Как удалить элемент из массива?

Так как массивы – это объекты, то можно попробовать delete:
	let arr = ["I", "go", "home"];
	delete arr[1]; // удалить "go"
	alert( arr[1] ); // undefined
	// теперь arr = ["I",  , "home"];
	alert( arr.length ); // 3

Элемент был удалён, но в массиве всё ещё три элемента, мы можем увидеть, что arr.length == 3.

Это естественно, потому что delete obj.key удаляет значение по ключу key. Это всё, что он делает. Хорошо для объектов. Но для массивов мы обычно хотим, чтобы оставшиеся элементы сдвинулись и заняли освободившееся место. Мы ждём, что массив станет короче.

Поэтому нужно использовать специальные методы.

Метод arr.splice – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы.

#### Синтаксис:

	arr.splice(start[, deleteCount, elem1, ..., elemN])

Он изменяет arr начиная с индекса start: удаляет deleteCount элементов и затем вставляет elem1, ..., elemN на их место. Возвращает массив из удалённых элементов.

Этот метод легко понять, рассмотрев примеры.

Начнём с удаления:
	let arr = ["Я", "изучаю", "JavaScript"];
	arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент
	alert( arr ); // осталось ["Я", "JavaScript"]

В следующем примере мы удалим 3 элемента и заменим их двумя другими.
	let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
	// удалить 3 первых элемента и заменить их другими
	arr.splice(0, 3, "Давай", "танцевать");
	alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]

# Перебор элементов

Одним из самых старых способов перебора элементов массива является цикл for по цифровым индексам:
	let arr = ["Яблоко", "Апельсин", "Груша"];
	for (let i = 0; i < arr.length; i++) {
	  alert( arr[i] );
	}

Но для массивов возможен и другой вариант цикла, for..of:
	let fruits = ["Яблоко", "Апельсин", "Слива"];
	// проходит по значениям
	for (let fruit of fruits) {
	  alert( fruit );
	}

Цикл for..of не предоставляет доступа к номеру текущего элемента, только к его значению, но в большинстве случаев этого достаточно. А также это короче.

Технически, так как массив является объектом, можно использовать и вариант for..in:
	let arr = ["Яблоко", "Апельсин", "Груша"];
	for (let key in arr) {
	  alert( arr[key] ); // Яблоко, Апельсин, Груша
	}

Для преобразования массива:
	- map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
	- sort(func) – сортирует массив «на месте», а потом возвращает его.
	- reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
	- split/join – преобразует строку в массив и обратно.
	- reduce/reduceRight(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.

Дополнительно:
	- Array.isArray(arr) проверяет, является ли arr массивом.