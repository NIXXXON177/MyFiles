**Объект** — это совокупность связанных данных и/или функциональных возможностей. Обычно состоят из нескольких переменных и функций, которые называются свойства и методы, если они находятся внутри объектов.
 
>>> const person = {};  
>>> // Object { }
 
Пустой объект («пустой ящик») можно создать, используя один из двух вариантов синтаксиса:
 
>>> let user = new Object(); // синтаксис "конструктор объекта"  
>>> let user = {}; // синтаксис "литерал объекта"
   

Поздравляем, вы только что создали ваш первый объект. Но это пустой объект, поэтому мы не можем с ним ничего сделать.  

Давайте обновим наш объект, чтобы он выглядел так:

>>> const person = {  
>>> 	name: \["Bob", "Smith"],  
>>> 	age: 32,  
>>> 	gender: "male",  
>>> 	interests: \["music", "skiing"],  
>>> 	bio: function () {  
>>> 	alert(  
>>> 		this.name\[0] +  
>>> 			" " +  
>>> 			this.name\[1] +  
>>> 			" is " +  
>>> 			this.age +  
>>> 			" years old. He likes " +  
>>> 			this.interests\[0] +  
>>> 			" and " +  
>>> 			this.interests\[1] +  
>>> 			".",  
>>> 		);  
>>> 	},  
>>> 	greeting: function () {  
>>> 		alert("Hi! I'm " + this.name\[0] + ".");  
>>> 	},  
>>> };
   

Объект состоит из нескольких элементов, каждый из которых имеет своё название (пример name и age выше), и значение (пример \['Bob', 'Smith'] и 32). Каждая пара название/значение должны быть разделены запятой, а название и значение в каждом случае разделяются двоеточием. Синтаксис всегда следует этому образцу:
 
>>> const objectName = {  
>>> 	member1Name: member1Value,  
>>> 	member2Name: member2Value,  
>>> 	member3Name: member3Value,  
>>> };
 
Для удаления свойства мы можем использовать оператор delete:
 
>>> delete user.age;
 
------------------------------------------
 
>>> let user = {};
>>>  
>>>// присваивание значения свойству  
>>> user\["likes birds"] = true;
>>>  
>>> // получение значения свойства  
>>> alert(user\["likes birds"]); // true
>>>  
>>> // удаление свойства  
>>> delete user\["likes birds"];
 
------------------------------------------
   

Значение члена объекта может быть чем угодно — в нашем объекте person есть строка, число, два массива, и две функции. Первые четыре элемента это элементы данных, относящиеся к свойствам объекта. Последние два элемента являются функциями, которые позволяют объекту что-то сделать с элементами данных, и называются методами объекта.
 
Такие объекты называются литералами объекта (object literal) — мы буквально вписали все содержимое объекта для его создания. Этот способ сильно отличается от объектов реализованных классами, которые мы рассмотрим позже.
 
# Точечная запись (Dot notation)
 
Выше вы получили доступ к свойствам и методам используя точечную запись (dot notation). Имя объекта (person) действует как пространство имён (namespace) — оно должно быть введено первым, для того чтобы получить доступ ко всему что заключено (encapsulated) внутри объекта. Далее вы пишете точку, затем элемент, к которому хотите получить доступ — это может быть имя простого свойства, элемент массива, или вызов одного из методов объекта, например:
 
>>> person.age;  
>>> person.interests[1];  
>>> person.bio();
 
# Внутренние пространства имён (Sub-namespaces)
 
Можно даже сделать значением элемента объекта другой объект. Например, попробуйте изменить значение свойства name с такого
 
>>> name: \['Bob', 'Smith'],  
>>> на такое
>>>  
>>> name : {  
>>> first: 'Bob',  
>>> last: 'Smith'  
>>> },
 
Здесь мы фактически создаём внутреннее пространство имён (sub-namespace). Это звучит сложно, но на самом деле это не так — для доступа к этим элементам вам нужно сделать один дополнительный шаг с ещё одной точкой. Попробуйте в консоли браузера следующее:
 
>>> person.name.first;  
>>> person.name.last;
 
Важно: На этом этапе вам также нужно будет пересмотреть код метода и изменить все экземпляры с
 
>>> name[0];  
>>> name[1];
>>>  
>>> на
>>>  
>>> name.first;  
>>> name.last;
 
# Скобочная запись (Bracket notation)
 
Существует другой способ получить свойства объекта — использовать скобочную запись (bracket notation). Вместо написания этого кода:
 
>>> person.age;  
>>> person.name.first;
 
Вы можете использовать следующий
 
>>> person["age"];  
>>> person["name"]["first"];
 
Это выглядит очень похоже на то, как вы получаете элементы массива, и в принципе это так и есть — вместо использования числовых индексов для выбора элемента, вы ассоциируете имя свойства для каждого значения. Ничего удивительного, что эти объекты иногда называют ассоциативными массивами — они сопоставляют строки со значениями так же, как массивы сопоставляют числовые индексы со значениями.
 
# Запись элементов в объект
 
До сих пор мы рассматривали только возврат (или получение) элементов объекта — вы так же можете установить (обновить) значение элемента объекта просто объявив элемент, который вы хотите установить (используя точечную или скобочную запись), например:
 
>>> person.age = 45;  
>>> person\["name"]\["last"] = "Cratchit";
 
Попробуйте ввести эти строки, а затем снова верните элементы, чтобы увидеть, как они изменились
 
>>> person.age;  
>>> person\["name"]\["last"];
   

Вы можете не просто обновлять и устанавливать значения свойств и методов объекта, а так же устанавливать совершенно новые элементы. Попробуйте их в консоли JS:
 
>>> person\["eyes"] = "hazel";  
>>> person.farewell = function () {  
>>> 	alert("Bye everybody!");  
>>> };
 
Одним из полезных аспектов скобочной записи является то, что с её помощью можно динамически задавать не только значения элементов, но и их имена. Предположим, что мы хотим, чтобы пользователи могли хранить пользовательские типы данных, введя имя и значение элемента в два следующих поля? Мы могли бы получить эти значения следующим образом:
 
>>> let myDataName = nameInput.value;  
>>> let myDataValue = nameValue.value;
 
Затем мы можем добавить имя и значение этого нового элемента в объект person таким образом:
 
>>> person\[myDataName] = myDataValue;

----------------------------------------------
 
Здесь переменная key может быть вычислена во время выполнения кода или зависеть от пользовательского ввода. После этого мы используем её для доступа к свойству. Это даёт нам большую гибкость.
 
>>> let user = {  
>>> 	name: "John",  
>>> 	age: 30  
>>> };
>>> let key = prompt("Что вы хотите узнать о пользователе?", "name");
>>> // доступ к свойству через переменную  
>>> alert( user[key] ); // John (если ввели "name")
 
# Вычисляемые свойства
 
Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.
 
>>> let fruit = prompt("Какой фрукт купить?", "apple");
>>> let bag = {  
>>> 	\[fruit]: 5, // имя свойства будет взято из переменной fruit  
>>>};
>>> alert( bag.apple ); // 5, если fruit="apple"
 
# Свойство из переменной
 
В реальном коде часто нам необходимо использовать существующие переменные как значения для свойств с тем же именем.
 
>>> function makeUser(name, age) {  
>>> 	return {  
>>> 		name: name,  
>>> 		age: age  
>>> 		// ...другие свойства  
>>> 	};  
>>> }
>>> let user = makeUser("John", 30);  
>>> alert(user.name); // John
 
В примере выше название свойств name и age совпадают с названиями переменных, которые мы подставляем в качестве значений этих свойств. Такой подход настолько распространён, что существуют специальные короткие свойства для упрощения этой записи.
 
Вместо name:name мы можем написать просто name:
 
>>> function makeUser(name, age) {  
>>> 	return {  
>>> 		name, // то же самое, что и name: name  
>>> 		age // то же самое, что и age: age  
>>> 		// ...  
>>> 	};  
>>> }
 
# Проверка существования свойства, оператор «in»
 
В отличие от многих других языков, особенность JavaScript-объектов в том, что можно получить доступ к любому свойству. Даже если свойства не существует – ошибки не будет!
 
При обращении к свойству, которого нет, возвращается undefined. Это позволяет просто проверить существование свойства:
 
>>> let user = {};
>>> alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
 
Также существует специальный оператор "in" для проверки существования свойства в объекте.
 
## Синтаксис оператора:
 
	"key" in object
 
Пример:
 
>>> let user = { name: "John", age: 30 };
>>>  
>>> alert( "age" in user ); // true, user.age существует  
>>> alert( "blabla" in user ); // false, user.blabla не существует
 
Для чего вообще нужен оператор in? Разве недостаточно сравнения с undefined?
 
В большинстве случаев прекрасно сработает сравнение с undefined. Но есть особый случай, когда оно не подходит и нужно использовать "in".
 
Это когда свойство существует, но содержит значение undefined:
 
>>> let obj = {  
>>> 	test: undefined  
>>> };
>>>  
>>> alert( obj.test ); // выведет undefined, значит свойство не существует?  
>>> alert( "test" in obj ); // true, свойство существует!
 
# Цикл "for..in"
 
Для перебора всех свойств объекта используется цикл for..in. Этот цикл отличается от изученного ранее цикла for(;;).
 
## Синтаксис:
 
>>> for (key in object) {  
>>> 	// тело цикла выполняется для каждого свойства объекта  
>>> }

К примеру, давайте выведем все свойства объекта user:

>>> let user = {  
>>> 	name: "John",  
>>> 	age: 30,  
>>> 	isAdmin: true  
>>> };
>>>  
>>> for (let key in user) {  
>>> 	// ключи  
>>> 	alert( key ); // name, age, isAdmin  
>>> 	// значения ключей  
>>> 	alert( user[key] ); // John, 30, true  
>>> }

# Итого
 
Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
 
Они хранят свойства (пары ключ-значение), где:
	- Ключи свойств должны быть строками или символами (обычно строками).
	- Значения могут быть любого типа.  

Чтобы получить доступ к свойству, мы можем использовать:
	- Запись через точку: obj.property.
	- Квадратные скобки obj\["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj\[varWithKey].
 
Дополнительные операторы:
	- Удаление свойства: delete obj.prop.
	- Проверка существования свойства: "key" in obj.
	- Перебор свойств объекта: цикл for for (let key in obj).
 
То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.
 
В JavaScript есть много других типов объектов:
	- Array для хранения упорядоченных коллекций данных,
	- Date для хранения информации о дате и времени,
	- Error для хранения информации об ошибке.
	- … и так далее.  

У них есть свои особенности, которые мы изучим позже. Иногда люди говорят что-то вроде «тип данных Array» или «тип данных Date», но формально они не являются отдельными типами, а относятся к типу данных Object. Они лишь расширяют его различными способами.