Оператор опциональной последовательности ?. позволяет получить значение свойства, находящегося на любом уровне вложенности в цепочке связанных между собой объектов, без необходимости проверять каждое из промежуточных свойств в ней на существование. ?. работает подобно оператору ., за исключением того, что не выбрасывает исключение, если объект, к свойству или методу которого идёт обращение, равен null или undefined. В этих случаях он возвращает undefined.
 
>>> const adventurer = {  
>>> 	name: 'Alice',  
>>> 	cat: {  
>>> 		name: 'Dinah',  
>>> 	},  
>>> };
>>>  
>>> const dogName = adventurer.dog?.name;  
>>> console.log(dogName);  
>>> // Expected output: undefined
>>>  
>>> console.log(adventurer.someNonExistentMethod?.());  
>>> // Expected output: undefined
 
## Синтаксис
 
>>> obj?.prop;  
>>> obj?.[expr];  
>>> arr?.[index];  
>>> func?.(args);
 
## Описание
 
Оператор опциональной последовательности предоставляет способ упростить доступ к значениям в цепочке объектов, когда возможно, что какое-то свойство (или метод) в ней равно undefined или null.
 
Для примера, создадим объект obj, имеющий вложенную структуру. Без оператора опциональной последовательности поиск глубоко расположенных подсвойств требует проверки всех промежуточных свойств на существование, например:
 
>>> let nestedProp = obj.first && obj.first.second;
 
Если обращаться к obj.first.second без проверки obj.first, то, если свойство obj.first равно null или undefined, выбросится исключение TypeError.
 
Однако, с оператором опциональной последовательности (?.) не требуется явно проверять ссылку на obj.first перед обращением к obj.first.second:
 
>>> let nestedProp = obj.first?.second;
 
## Опциональная последовательность с вызовом функции
 
Вы можете использовать ?., когда необходимо вызвать метод, которого может не существовать. Это может быть полезно, например, при использовании API, в котором метод может быть недоступен из-за устаревания или не поддерживаемости устройством пользователя.
 
Использование ?. с вызовом функции значит, что выполнение автоматически вернёт undefined, а не выбросит исключение, если метод не найден:
 
>>> let result = someInterface.customMethod?.();
   

## Работа с колбэк-функциями и обработчиками событий
 
Если вы используете колбэк-функции или извлекаете методы объекта деструктурирующим присваиванием, Вы можете получить несуществующие значения, которые нельзя вызывать как функции до проверки на их существование. Используя оператор ?., вы можете избежать лишних проверок:
 
>>> // С использованием ES2019  
>>> function doSomething(onContent, onError) {  
>>> 	try {  
>>> 		// ... делаем что-то с данными  
>>> 	} catch (err) {  
>>> 		if (onError) {  
>>> 			// проверяем, существует ли onError  
>>> 			onError(err.message);  
>>> 		}  
>>> 	}  
>>> }
>>>  
>>> // С использованием оператора опциональной последовательности  
>>> function doSomething(onContent, onError) {  
>>> 	try {  
>>> 		// ... делаем что-то с данными  
>>> 	} catch (err) {  
>>> 		onError?.(err.message); // не выбросит исключение, если onError равен undefined  
>>> 	}  
>>> }
 
## Опциональные последовательности в выражениях
 
Вы также можете использовать оператор опциональной последовательности, когда обращаетесь к свойству с помощью скобочной нотации:
 
>>> let nestedProp = obj?.["prop" + "Name"];
 
## Сокращённое выполнение
 
При использовании оператора опциональной последовательности в выражениях, где левая часть операнда равна null или undefined, выражение не будет выполнено. Например:
 
>>> let potentiallyNullObj = null;  
>>> let x = 0;  
>>> let prop = potentiallyNullObj?.[x++];
>>>  
>>> console.log(x); // 0, т.к. x не был инкрементирован
 
## Использование с оператором ??
 
Оператор ?? может использоваться после опциональной последовательности для установления значения по умолчанию:
 
>>> let customer = {  
>>> 	name: "Carl",  
>>> 	details: { age: 82 },  
>>> };  
>>> const customerCity = customer?.city ?? "Unknown city";  
>>> console.log(customerCity); // Unknown city