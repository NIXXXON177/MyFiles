1. Итеративный способ: цикл for:

>>> function pow(x, n) {  
>>> 	let result = 1;
>>> 	// умножаем result на x n раз в цикле  
>>> 	for (let i = 0; i < n; i++) {  
>>> 		result *= x;  
>>> 	}
>>> 	return result;  
>>> }
>>>  
>>> alert( pow(2, 3) ); // 8

 2. Рекурсивный способ: упрощение задачи и вызов функцией самой себя:
   
>>> function pow(x, n) {  
>>> 	if (n == 1) {  
>>> 		return x;  
>>> 	} else {  
>>> 		return x * pow(x, n - 1);  
>>> 	}  
>>> }
>>>  
>>> alert( pow(2, 3) ); // 8
   
Используя условный оператор ? вместо if, мы можем переписать pow(x, n), делая код функции более лаконичным, но всё ещё легко читаемым:
 
>>> function pow(x, n) {  
>>> 	return (n == 1) ? x : (x * pow(x, n - 1));  
>>> }
 
## Контекст выполнения, стек
 
Теперь мы посмотрим, как работают рекурсивные вызовы. Для этого заглянем «под капот» функций.
 
Информация о процессе выполнения запущенной функции хранится в её контексте выполнения (execution context).
 
Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение this (мы не используем его в данном примере) и прочую служебную информацию.
 
Один вызов функции имеет ровно один контекст выполнения, связанный с ним.
 
Когда функция производит вложенный вызов, происходит следующее:
	- Выполнение текущей функции приостанавливается.
	- Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.
	- Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
	- После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.
 
## Связанный список
 
Представьте себе, что мы хотим хранить упорядоченный список объектов.
 
Естественным выбором будет массив:
 
>>> let arr = \[obj1, obj2, obj3];
 
…Но у массивов есть недостатки. Операции «удалить элемент» и «вставить элемент» являются дорогостоящими. Например, операция arr.unshift(obj) должна переиндексировать все элементы, чтобы освободить место для нового obj, и, если массив большой, на это потребуется время. То же самое с arr.shift().
 
Единственные структурные изменения, не требующие массовой переиндексации – это изменения, которые выполняются с конца массива: arr\.push/pop. Таким образом, массив может быть довольно медленным для больших очередей, когда нам приходится работать с его началом.
 
Или же, если нам действительно нужны быстрые вставка/удаление, мы можем выбрать другую структуру данных, называемую связанный список.
 
Элемент связанного списка определяется рекурсивно как объект с:
	- value,
	- next – свойство, ссылающееся на следующий элемент связанного списка или null, если это последний элемент.  

Пример:
 
>>> let list = {  
>>> 	value: 1,  
>>> 	next: {  
>>> 		value: 2,  
>>> 		next: {  
>>> 			value: 3,  
>>> 			next: {  
>>> 				value: 4,  
>>> 				next: null  
>>> 			}  
>>> 		}  
>>> 	}  
>>> };
 
Графическое представление списка:
 ![Exported image](cache/Exported%20image%2020250112225538-0.png)

Альтернативный код для создания:
 
>>> let list = { value: 1 };  
>>> list.next = { value: 2 };  
>>> list.next.next = { value: 3 };  
>>> list.next.next.next = { value: 4 };  
>>> list.next.next.next.next = null;
 
Здесь мы можем ещё лучше увидеть, что есть несколько объектов, каждый из которых имеет value и next, указывающий на соседа. Переменная list является первым объектом в цепочке, поэтому, следуя по указателям next из неё, мы можем попасть в любой элемент.
 
Список можно легко разделить на несколько частей и впоследствии объединить обратно:
 
>>> let secondList = list.next.next;  
>>> list.next.next = null;

 ![Exported image](cache/Exported%20image%2020250112225540-1.png)  

Для объединения:
 
>>> list.next.next = secondList;
 
И, конечно, мы можем вставить или удалить элементы из любого места.
 
Например, для добавления нового элемента нам нужно обновить первый элемент списка:
 
>>> let list = { value: 1 };  
>>> list.next = { value: 2 };  
>>> list.next.next = { value: 3 };  
>>> list.next.next.next = { value: 4 };  
>>> list.next.next.next.next = null;
>>>  
>>> // добавление нового элемента в список  
>>> list = { value: "new item", next: list };
 
 ![Exported image](cache/Exported%20image%2020250112225542-2.png)  

Чтобы удалить элемент из середины списка, нужно изменить значение next предыдущего элемента:
 
>>> list.next = list.next.next;

 ![Exported image](cache/Exported%20image%2020250112225545-3.png)  

list.next перепрыгнуло с 1 на значение 2. Значение 1 теперь исключено из цепочки. Если оно не хранится где-нибудь ещё, оно будет автоматически удалено из памяти.
 
В отличие от массивов, нет перенумерации, элементы легко переставляются.
 
Естественно, списки не всегда лучше массивов. В противном случае все пользовались бы только списками.
 
Главным недостатком является то, что мы не можем легко получить доступ к элементу по его индексу. В простом массиве: arr\[n] является прямой ссылкой. Но в списке мы должны начать с первого элемента и перейти в next N раз, чтобы получить N-й элемент.
 
…Но нам не всегда нужны такие операции. Например, нам может быть нужна очередь или даже двухсторонняя очередь – это упорядоченная структура, которая позволяет очень быстро добавлять/удалять элементы с обоих концов, но там не нужен доступ в середину.
 
Списки могут быть улучшены:
	- Можно добавить свойство prev в дополнение к next для ссылки на предыдущий элемент, чтобы легко двигаться по списку назад.
	- Можно также добавить переменную tail, которая будет ссылаться на последний элемент списка (и обновлять её при добавлении/удалении элементов с конца).
	- …Возможны другие изменения: главное, чтобы структура данных соответствовала нашим задачам с точки зрения производительности и удобства.
 
# Итого
 
Термины:
- Рекурсия – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач.
 
Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.
 
- Рекурсивно определяемая структура данных – это структура данных, которая может быть определена с использованием самой себя.
 
Например, связанный список может быть определён как структура данных, состоящая из объекта, содержащего ссылку на список (или null).
 
	list = { value, next -> list }
 
Деревья, такие как дерево HTML-элементов или дерево отделов из этой главы, также являются рекурсивными: у них есть ветви, и каждая ветвь может содержать другие ветви.
 
Как мы видели в примере sumSalary, рекурсивные функции могут быть использованы для прохода по ним.
 
Любая рекурсивная функция может быть переписана в итеративную. И это иногда требуется для оптимизации работы. Но для многих задач рекурсивное решение достаточно быстрое и простое в написании и поддержке.